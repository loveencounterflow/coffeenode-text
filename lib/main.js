// Generated by CoffeeScript 1.7.1
(function() {
  var BAP, TRM, TYPES, log, rpr, _fill_in_matcher,
    __slice = [].slice;

  BAP = require('coffeenode-bitsnpieces');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  log = TRM.log.bind(TRM);

  this.repeat = function(me, count) {
    return (new Array(count + 1)).join(me);
  };

  this.push = function(me, you) {
    return me + you;
  };

  this.copy = function(me) {
    return me;
  };

  this.starts_with = function(me, probe, idx) {
    if (idx == null) {
      idx = 0;
    }
    return (me.lastIndexOf(probe, idx)) === idx;
  };

  this.ends_with = function(me, search_text) {
    var delta;
    delta = me.length - search_text.length;
    return delta >= 0 && (me.lastIndexOf(search_text)) === delta;
  };

  this.drop_prefix = function(me, probe) {
    if (this.starts_with(me, probe)) {
      return me.substr(probe.length);
    }
    return me;
  };

  this.drop_suffix = function(me, probe) {
    if (this.ends_with(me, probe)) {
      return me.substr(0, me.length - probe.length);
    }
    return me;
  };

  this.contains = function(me, probe) {
    var type_of_probe;
    switch (type_of_probe = TYPES.type_of(probe)) {
      case 'text':
        if (probe.length === 0) {
          return true;
        }
        return (me.indexOf(probe)) >= 0;
      case 'jsregex':
        return (me.match(probe)) != null;
      default:
        throw new Error("unknown type for TEXT/contains: " + type_of_probe);
    }
  };

  this.contains_only_digits = function(me) {
    if (this.is_empty(me)) {
      return false;
    }
    return (me.match(/^[0-9]+$/)) != null;
  };

  this.is_empty = function(me) {
    return me.length === 0;
  };

  this.split = function(me, splitter) {

    /* Given a text (`me`) and a `splitter` (which may be a text or a RegEx), return the result of doing the
    JS String method `me.split splitter`. However, when `splitter` is not defined, return a list of characters
    in the text, respecting Unicode surrogate pairs.
     */
    var R, filter;
    if (splitter != null) {
      filter = null;
    } else {
      splitter = /((?:[\ud800-\udbff][\udc00-\udfff])|.)/;
      filter = function(chunk) {
        return chunk !== '';
      };
    }
    R = me.split(splitter);
    if (filter == null) {
      return R;
    } else {
      return R.filter(filter);
    }
  };


  /* TAINT.TODO "might not recognize all Unicode whitespace codepoints"
   */

  this.words_of = function(me) {
    return (me.replace(/^\s*(.*?)\s*$/g, '$1')).split(/\s+/g);
  };

  this.as_text = function(me) {
    return me;
  };

  this.trim = function(me) {
    return this._trim_whitespace(me, true, true);
  };

  this.trim_left = function(me) {
    return this._trim_whitespace(me, true, false);
  };

  this.trim_right = function(me) {
    return this._trim_whitespace(me, false, true);
  };

  this._trim_whitespace = function(me, trim_left, trim_right) {

    /*Faster whitespace trimming; adapted from
    http://blog.stevenlevithan.com/archives/faster-trim-javascript.
     */
    var i, whitespace;
    if (trim_left) {
      me = me.replace(/^\s\s*/, '');
    }
    if (trim_right) {
      whitespace = /\s/;
      i = me.length;
      while (whitespace.test(me.charAt(--i))) {
        null;
      }
      me = me.slice(0, i + 1);
    }
    return me;
  };

  this.flush_left = function(x, width, filler) {
    if (width == null) {
      width = 25;
    }
    if (filler == null) {
      filler = ' ';
    }
    return this.flush(x, width, 'left', filler);
  };

  this.flush_right = function(x, width, filler) {
    if (width == null) {
      width = 25;
    }
    if (filler == null) {
      filler = ' ';
    }
    return this.flush(x, width, 'right', filler);
  };

  this.flush = function(x, width, align, filler) {
    var filler_length, padding, text_length;
    if (filler == null) {
      filler = ' ';
    }

    /*Given a value, a non-negative integer ``width``, and an optional, non-empty text ``filler`` (which
    defaults to a single space), return a string that starts with the text (or the text of the representation
    of the value), and is padded with as many fillers as needed to make the string ``width`` characters long.
    If ``width`` is zero or smaller than the length of the text, the text is simply returned as-is. No
    clipping of text is ever done.
     */
    if (!(align === 'left' || align === 'right')) {
      throw new Error("expected ``left`` or ``right`` for ``align``, got " + (rpr(align)));
    }
    if (!TYPES.isa_text(x)) {
      x = rpr(x);
    }
    filler_length = filler.length;
    text_length = x.length;
    if (text_length >= width) {
      return x;
    }
    padding = this.repeat(filler, width - text_length);
    if (align === 'left') {
      return x + padding;
    } else {
      return padding + x;
    }
  };

  this.lower_case = function(me) {
    return me.toLowerCase();
  };

  this.upper_case = function(me) {
    return me.toUpperCase();
  };


  /* TAINT.UNICODE will incorrectly count codepoints above u/ffff as two chrs
   */

  this.length_of = function(me) {
    return me.length;
  };

  this.lines_of = function(me, handler) {

    /*Given a text and an optional handler, either return a list of lines (without line endings) if handler
    is not given, or call handler as `handler error, line` for each line in the text, and one more call where
    `line` is `null` after the end of the text has been encountered. In either case, all lines will be
    stripped of trailine whitespace, including newline characters; recognized newlines are the usual suspects
    for Unix, Windows, and MacOS systems (namely, `\\n`, `\\r\\n`, and `\\r`).
    
    **Implementation Note**: Implementation of asynchronous version postponed.
     */
    if (handler == null) {
      return me.split(this._line_splitter);
    }
    throw new Error("asynchronous TEXT.lines_of not yet supported");
  };

  this._line_splitter = /\r\n|[\n\v\f\r\x85\u2028\u2029]/g;

  this.reverse = function(me) {
    return (this.chrs_of(me)).reverse().join('');
  };

  this.add = function() {
    var me_and_you;
    me_and_you = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return me_and_you.join('');
  };


  /* TAINT.UNICODE "will split codepoints beyond u/ffff"
   */

  this.partition = function(me, partitioner) {
    var R, idx, m, max_idx, n, remainder, _i;
    n = partitioner;
    m = me.length;
    idx = -n;
    max_idx = m - n;
    remainder = m % n;
    R = [];
    if (remainder !== 0) {
      throw new Error("expected length of text to be a multiple of " + n + ", got text with " + m + " characters");
    }
    for (idx = _i = 0; n > 0 ? _i <= max_idx : _i >= max_idx; idx = _i += n) {
      R.push(this.slice(me, idx, idx + n));
    }
    return R;
  };

  this.slice = function(me, start, stop) {
    if (start == null) {
      start = 0;
    }
    if (stop == null) {
      stop = me.length;
    }
    if (start >= stop) {
      return '';
    }
    return me.slice(start, stop);
  };

  this.shuffle = function(me) {
    return (LIST.shuffle(this.chrs_of(me))).join('');
  };

  this.list_of_unique_chrs = function(me) {

    /* Given a text, return a list of all unique characters in the text. The implementation uses `TEXT.split`
    to obtain the characters, which means that it respects Unicode surrogate pairs. The characters will appear
    in the order they appear in the original text.
     */
    var R, all_chrs, chr, seen_chrs, _i, _len;
    all_chrs = this.split(me);
    R = [];
    seen_chrs = {};
    for (_i = 0, _len = all_chrs.length; _i < _len; _i++) {
      chr = all_chrs[_i];
      if (seen_chrs[chr] != null) {
        continue;
      }
      R.push(chr);
      seen_chrs[chr] = 1;
    }
    return R;
  };

  this.validate_is_nonempty_text = function(me) {
    TYPES.validate_isa_text(me);
    if (!(me.length > 0)) {
      throw new Error("expected a non-empty text, got an empty one");
    }
  };

  this.validate_is_word = function(me) {
    this.validate_is_nonempty_text(me);
    if ((me.match(/^\S+$/)) == null) {
      throw new Error("expected a non-empty text without whitespace");
    }
  };

  this._fill_in_get_method = function(matcher) {
    return function(template, data_or_handler) {
      var R, data, handler;
      if (TYPES.isa_function(data_or_handler)) {
        handler = data_or_handler;
        data = null;
      } else {
        data = data_or_handler;
        handler = null;
      }
      R = template.replace(matcher, (function(_this) {
        return function(ignored, prefix, markup, bare, bracketed, tail) {
          var container, key, name, new_value, _ref;
          name = bare != null ? bare : bracketed;
          if (handler != null) {
            return handler(null, name);
          }
          if (name[0] !== '/') {
            name = '/' + name;
          }
          _ref = BAP.container_and_facet_from_locator(data, name), container = _ref[0], key = _ref[1], new_value = _ref[2];
          return prefix + (TYPES.isa_text(new_value) ? new_value : rpr(new_value)) + tail;
        };
      })(this));
      return R;
    };
  };


  /* TAINT use options argument */

  this._fill_in_get_matcher = function(activator, opener, closer, seperator, escaper, forbidden) {
    if (activator == null) {
      activator = '$';
    }
    if (opener == null) {
      opener = '{';
    }
    if (closer == null) {
      closer = '}';
    }
    if (seperator == null) {
      seperator = ':';
    }
    if (escaper == null) {
      escaper = '\\';
    }
    if (forbidden == null) {
      forbidden = "{}<>()|*+.,;:!\"'$%&/=?`Â´#";
    }
    forbidden = this.list_of_unique_chrs(activator + opener + closer + seperator + escaper + forbidden);
    forbidden = (BAP.escape_regex(forbidden.join(''))) + '\\s';
    activator = BAP.escape_regex(activator);
    opener = BAP.escape_regex(opener);
    closer = BAP.escape_regex(closer);
    seperator = BAP.escape_regex(seperator);
    escaper = BAP.escape_regex(escaper);
    return RegExp("([^" + escaper + "]|^)(" + activator + "(?:([^" + forbidden + "]+)|" + opener + "(" + escaper + activator + "|" + escaper + opener + "|" + escaper + closer + "|[^" + activator + opener + closer + "]+)" + closer + "))([^" + activator + "]*)$");
  };

  _fill_in_matcher = this._fill_in_get_matcher();

  this.fill_in = this._fill_in_get_method(_fill_in_matcher);

  this.fill_in.matcher = _fill_in_matcher;

  this.fill_in.get_matcher = this._fill_in_get_matcher.bind(this);


  /* TAINT use options argument */

  this.fill_in.create = function(activator, opener, closer, seperator, escaper) {
    var R, matcher;
    matcher = this.fill_in.get_matcher(activator, opener, closer, seperator, escaper);
    R = _fill_in_get_method(matcher);
    return R;
  };

  this.fill_in.create = this.fill_in.create.bind(this);

  this.fill_in.container = function(container, handler) {

    /* TAINT does not yet support custom matchers */
    var change_count, errors, m;
    errors = null;
    while (true) {
      change_count = 0;
      BAP.walk_containers_crumbs_and_values(container, (function(_this) {
        return function(error, sub_container, crumbs, old_value) {
          var does_match, key, locator, message, new_value;
          if (error != null) {
            throw error;
          }

          /* TAINT call handler on termination? */
          if (crumbs === null) {
            return;
          }
          if (!TYPES.isa_text(old_value)) {
            return;
          }
          does_match = _this.fill_in.matcher.test(old_value);
          new_value = _this.fill_in(old_value, handler != null ? handler : container);
          if (does_match) {
            if (old_value === new_value) {
              locator = '/' + crumbs.join('/');
              message = "* unable to resolve " + locator + ": " + (rpr(old_value)) + " (circular reference?)";
              return (errors = errors != null ? errors : {})[message] = 1;
            } else {
              key = crumbs[crumbs.length - 1];
              sub_container[key] = new_value;
              return change_count += 1;
            }
          }
        };
      })(this));
      if (change_count === 0) {
        break;
      }
    }
    if (errors != null) {
      throw new Error('\nerrors have occurred:\n' + (((function() {
        var _results;
        _results = [];
        for (m in errors) {
          _results.push(m);
        }
        return _results;
      })()).sort().join('\n')) + '\n');
    }

    /* TAINT should be calling handler on error */
    return container;
  };

  this.fill_in.container = this.fill_in.container.bind(this);

}).call(this);
